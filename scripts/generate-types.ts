#!/usr/bin/env ts-node-transpile-only

import { strict as assert } from "assert";
import * as fs from "fs";
import { JSONSchema7, JSONSchema7Definition } from "json-schema";
import { format } from "prettier";

type JSONSchemaWithRef = JSONSchema7 & Required<Pick<JSONSchema7, "$ref">>;

interface Schema extends JSONSchema7 {
  definitions: Record<string, JSONSchema7>;
  oneOf: JSONSchemaWithRef[];
}

const schema = require("@octokit/webhooks-schemas") as Schema;

const guessAtEventName = (name: string) => {
  const [, eventName] = /^(.+)[$_-]event/u.exec(name) ?? [];

  assert.ok(eventName, `unable to guess event name for "${name}"`);

  return eventName;
};
const guessAtActionName = (name: string) => name.replace("$", ".");

const getDefinitionName = (ref: string): string => {
  assert.ok(
    ref.startsWith("#/definitions/"),
    `${ref} does not reference a valid definition`
  );

  const [, name] = /^#\/definitions\/(.+)$/u.exec(ref) ?? [];

  assert.ok(name, `unable to find definition name ${ref}`);

  return name;
};

type NameAndActions = [name: string, actions: string[]];

const buildEventProperties = ([
  eventName,
  actions,
]: NameAndActions): string[] => [
  guessAtEventName(eventName),
  ...actions.map(guessAtActionName),
];

const isJSONSchemaWithRef = (
  object: JSONSchema7Definition
): object is JSONSchemaWithRef =>
  typeof object === "object" && object.$ref !== undefined;

const listEvents = () => {
  return schema.oneOf.map<NameAndActions>(({ $ref }) => {
    const name = getDefinitionName($ref);
    const definition = schema.definitions[name];

    assert.ok(definition, `unable to find definition named ${name}`);

    if (definition.oneOf?.every(isJSONSchemaWithRef)) {
      return [name, definition.oneOf.map((def) => getDefinitionName(def.$ref))];
    }

    return [name, []];
  });
};

const getEmitterEvents = (): string[] => {
  return listEvents().reduce<string[]>(
    (properties, event) => properties.concat(buildEventProperties(event)),
    []
  );
};

const outDir = "src/generated/";

const generateTypeScriptFile = (name: string, contents: string[]) => {
  fs.writeFileSync(
    `${outDir}/${name}.ts`,
    format(contents.join("\n"), { parser: "typescript" })
  );
};

const asCode = (str: string): string => `\`${str}\``;
const asLink = (event: string): string => {
  const link = `https://docs.github.com/en/developers/webhooks-and-events/webhooks/webhook-events-and-payloads#${event.replace(
    /[^a-z_]/g,
    ""
  )}`;

  return `[${asCode(event)}](${link})`;
};

const updateReadme = (properties: string[]) => {
  const headers = "| Event | Actions |";

  const events = properties.reduce<Record<string, string[]>>(
    (events, property) => {
      console.log(property);
      const [event, action] = property.split(".");

      events[event] ||= [];

      if (action) {
        events[event].push(action);
      }

      return events;
    },
    {}
  );

  const rows = Object.entries(events).map(
    ([event, actions]) =>
      `| ${asLink(event)} | ${actions.map(asCode).join("<br>")} |`
  );

  const table = format([headers, "| --- | --- |", ...rows].join("\n"), {
    parser: "markdown",
  });

  const readme = fs.readFileSync("README.md", "utf-8");

  const TableStartString =
    "<!-- autogenerated via scripts/generate-types.ts -->";
  const TableEndString =
    "<!-- /autogenerated via scripts/generate-types.ts -->";
  const tableStartIndex = readme.indexOf(TableStartString);
  const tableEndIndex = readme.indexOf(TableEndString);

  assert.ok(tableStartIndex !== -1, "cannot find start of table");
  assert.ok(tableEndIndex !== -1, "cannot find end of table");

  fs.writeFileSync(
    "README.md",
    `${readme.slice(
      0,
      tableStartIndex + TableStartString.length
    )}\n\n${table}\n${readme.slice(tableEndIndex)}`
  );
};

const run = () => {
  const emitterEvents = getEmitterEvents();

  generateTypeScriptFile("webhook-names", [
    "// THIS FILE IS GENERATED - DO NOT EDIT DIRECTLY",
    "// make edits in scripts/generate-types.ts",
    "",
    "export const emitterEventNames = [",
    ...emitterEvents.map((key) => `"${key}",`),
    "] as const;",
  ]);

  updateReadme(emitterEvents);
};

run();
